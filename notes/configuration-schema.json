// This is an example config file detailing all of the supported standard actions 
// in the library.

{
  // Provide the type of activity this is enriching.  This should be the same
  // as the name of the kafka queue.
  "activityType": "impressions",

  // Some global configuration settings.
  "global": {

    // This is an action list containing any actions that you need to perform in
    // the event that an action throws an (unhandled) exception during perform().
    // Any action can be provided.  These actions should not throw!  
    "exceptionHandlingList": [ { "actionType": "...", "config": {} } ],

//    // You can configure JDBC client(s) to be used here.  They are set up on each
//    // executor via sc.mapPartitions(), and each action will have access to them 
//    // through the ActionContext.
//    "jdbcClients": [
//      {
//        // The name must be unique so it can be accessed in the jdbcClients collection.
//        "name": "hive",
//
//        // The connection string needed to connect to the JDBC resource.
//        // This can be hardcoded, but if it starts with "$", it will be read from 
//        // the current environment.
//        "connectionUri": "$HIVE_JDBC_CONNECTION_URI"
//        //"connectionUri": """jdbc:hive2://$HOST.cars.com:10000/master_data;principal=hive/$HOST@CORP.CLASSIFIEDVENTURES.COM""" // todo update wiki if this works
//      }
//    ]
  }

  "items": [
    {
      // The name field is strictly for the author's use, to name this item, 
      // which is just a sequence of actions.  The best practice is to name it 
      // after the output field in the enriched record that this list generates.  
      // If it generates more than one field, name them all, or use something generic 
      // like "all the simple-copy fields".   This field is not used in the code at 
      // all.
      "name": "name_of_this_item",

      // All the actions to perform, in sequence, in order to output a specific field 
      // in the enriched record.
      "actions": [

        // --------------------------------------------------------------------
        // Custom actions can have anything in the "config" section.
        // They must have a custom ActionCreator object passed to the ActionFactory.
        // If you notice you are re-using custom actions, they may be a candidate
        // to be added to the framework.
        {
          "actionType": "custom",
          "config": {
              "any": "thing",
              "someOther": [ "things" ]
          }
        },

        // --------------------------------------------------------------------
        // AddRejectionReason adds the rejection reason stored in the scratchpad
        // (as a result of Reject action(s) - see below) to the field below, and
        // copies the rest of the input record to the enriched record.
        // This is best done at the end of a set of items as well as in the 
        // global.exceptionHandlingList.
        {
          "actionType":"add-rejection-reason",
          "config": {
            // The name of the field in the enriched record to add the rejection
            // reason to:
            "field": "reasonForReject"
          }
        },

        // --------------------------------------------------------------------
        // Simple copy copies each source field from the input record directly to 
        // the same-named field in the output record.
        {
          "actionType": "simple-copy",
          "config": {
            "inputSource": [ "field1", "field2" ] // etc.
          }
        },

        // --------------------------------------------------------------------
        // Check does a check on a field and if it passes, runs some actions.
        // If the check fails, it runs some other actions.
        {
          "actionType": "check",

          "config": {

            // The "left" operand in the check operation.  For unary checks
            // (null, empty, etc.), this is the only operand required.
            // For unary checks, you may also name it "field", which makes more 
            // sense in this context.
            "left": "fieldA",

            // (Optional) Specify where to pull the left field from, either
            // the inputRecord or the enriched record up to this point.
            // If not specified, the default is to check the enriched record; 
            // if not found there, it looks in the inputRecord.
            // For unary checks, you may also name it "fieldSource", which makes 
            // more sense in this context.
            "leftSource": "enriched|input"

            // The operator.  Valid operators are currently:
            //   * empty
            //   * non-empty
            //   * null
            //   * non-null
            //   * numeric
            //   * non-numeric
            "op": "non-empty",

            // Note - binary checks are unimplemented yet, but this is how they
            // would be configured (using "right" and "rightSource", below):
            
            // (OPTIONAL) The right-hand operand.  This is required for binary 
            // checks (such as "<" or "=").  If this is NOT a binary check (only
            // one field is being analyzed), and this is specified, the parser
            // will error out and let you know.
            //"right": "fieldB",

            // (OPTIONAL) Specify where to pull the right field from, either
            // the inputRecord or the enriched record up to this point.
            // If not specified, the default is to check the enriched record; 
            // if not found there, it looks in the inputRecord.
            //"rightSource": "enriched|input",

            // (OPTIONAL) If the check passes (the result is 'yes' or 'true'), then 
            // all of the actions in the onPass list will be run. 
            "onPass": [
              {
                "actionType": "custom-action",
                "config": { "key": "val" }
              },
              {
                "actionType": "custom-action2",
                "config": { "key": "val2" }
              }
            ],

            // (OPTIONAL) If the check fails (the result is 'no' or 'false'), then 
            // all of the actions in the onPass list will be run. 
            "onFail": [
               {
                 "actionType": "custom-action",
                 "config": { "key": "val" }
               },
               {
                 "actionType": "reject",
                 "config": {
                   "reasonFrom": "check"
                 }
               }
            ]
          }
        }

        // --------------------------------------------------------------------
        // Copy copies a field's value into a potentially-differently-named field.
        // More configurable than simple-copy.  For each element in config, 
        // you must specify a 'source' and an 'enrichedField' (destination).
        {
          "actionType": "copy",
          "config": {
            "config": [
              {
                "inputSource":  "name_of_field_from_input_record", 
                "outputTarget": "name_of_field_in_output_record"
              },
              {
                "inputSource":  "name_of_field_from_input_record2", 
                "outputTarget": "name_of_field_in_output_record2"
              }
              // etc.
            ]
          }
        },

        // --------------------------------------------------------------------
        // "ReplaceNull" checks for a null value in the input field(s),
        // and if the value exists and is null (or does not exist), it will set 
        // the enriched record's field value to be some hard-coded value.  
        {
          "actionType": "replace-null",
          "config": {

            // Either 'field' or 'fields' must be specified, or there is an error.
            // This is the field (or fields) to check for null, and if they are
            // null or missing in the input, then the new value is written.
            // By default, the field is searched for first in the enriched record, 
            // then if not found, the input record is searched.  This can be 
            // overridden by specifying a location modifier in front of the field 
            // like so:
            //
            //    "$enriched.fieldA" = search the enriched record only
            //    "$input.fieldA" = search the input record only
            "field":  "fieldA",
            "fields": [ "fieldB", "fieldC", "..."],

            // This is the exact value to write for this field.  
            "newValue": "Some text",

            // Specify where the new value is written to.  Valid values are:
            //   "enriched" = the enriched record (the default; not necessary to specify)
            //   "scratchpad" = the scratchpad (temporary storage, only lives for 
            //                  while this record is being processed - from this
            //                  point forward)
            "outputTo": "scratchpad",
          }
        },

        //-------------------------------------------------------------------
        //translate
        // Does multiple customized lookups directly to enrichment
        //this custom action mainly focuses on fields like 'classified_ad_id' and 'seller_role_pty_id' in impressions
        //the action performs two sets of actions depending on valid classified_ad_id and invalid classified_ad_id
        //some of the values inside this action are hardcoded which are very specific to impressions topic
        {
          "actionType" : "translate",
          "config":{

            //mandatory inputSource. we check for this value in input if valid or notvalid.
            //the schema of lookups inside ifValid and IfNotValid resembles the schema of 'lookup' action
            "inputSource" : "inputField",

            //valid meaning inputField is greater than 0 and not null
            //ifValid is a list of lookups.
            //As long as the "inputField" value in input is valid ,
            //we dont have to mention an 'inputSource' in each element of 'ifValid' list
            "ifValid" : [
              {
                //"overrideSource" is entirely optional.
                //for OverrideSource, "xyz" is searched as a key inside the results collected so far in ifValid list processing.
                // the list of ifValid is a cumulative map datastructure
                //if overrideSource key is not found in the so far collected ifValid resultSet, "onFail" segment of that element gets executed
                //unlike "equals" in "lookup" action, we take inputSource's value from input to grab enriched fields for select fields.
                //overrideSource is added for situations like do a lookup get the enriched key/value("X"/"something") in a temp map, if another lookup needs X's value as inputSource,
                //then just mention overrideSource : "X" in the config for the latter lookup.
                // overrideSource looks for a key ONLY in a temp map or result Set of ifValid config in translate action.
                "overrideSource" : "xyz",
                "select" : [""],
                "fromDBTable" : "",
                "where" : "",
                //list of any valid actions when lookup is successful. Optional
                "onPass" : [
                  {
                    "actionType": "custom-action",
                    "config": { "key": "val" }
                  },
                  {
                    "actionType": "custom-action2",
                    "config": { "key": "val2" }
                  }
                ],
                //list of any valid actions when lookup is unsuccessful. Mandatory
                "onFail" : [
                  {
                    "actionType": "custom-action",
                    "config": { "key": "val" }
                  },
                  {
                    "actionType": "custom-action2",
                    "config": { "key": "val2" }
                  }
                ]
              },

              {
                //overrideSOurce is ignored here..this is just an example.
                "select" : [""],
                "fromDBTable" : "",
                "where" : "",
                "onPass" : [
                  {
                    "actionType": "custom-action",
                    "config": { "key": "val" }
                  },
                  {
                    "actionType": "custom-action2",
                    "config": { "key": "val2" }
                  }
                ],
                "onFail" : [
                  {
                    "actionType": "custom-action",
                    "config": { "key": "val" }
                  },
                  {
                    "actionType": "custom-action2",
                    "config": { "key": "val2" }
                  }
                ]
              },

              {
                //another ifValid element of lookup actions and so on..
              }

            ],

            //list of all lookups to be done when value of inputSource is invalid.meaning <=0 or ==null
            "ifNotValid" : [
              {
                //since the value of "inputSource" (top) is Invalid,
                //each individual element inside ifNotValid list is gonna have its own "inputSource"
                //"inputSource" key/value pair inside each element of ifNotValid list is mandatory.
                "inputSource" : "BField",

                //ifZero is optional. this comes into picture when inputValue of "inputSource" ("BField") is "0"
                //In this case, if the raw input value of  BField is "0" then "BField" is assigned "abc" in enriched without performing any lookup
                "ifZero" : "abc",

                //list of non-null and valid select string fields. Mandatory
                "select" : [""],
                //fromDbTable should non-null and valid db.tablename. Mandatory
                "fromDBTable" : "",
                //fromDbTable should non-null and valid where field. Mandatory.
                //"equals" is not required here because by default "inputSource" is acting like "equals"
                "where" : "",

                //list of any valid actions when lookup is successful. Optional
                "onPass" : [
                  {
                    "actionType": "custom-action",
                    "config": { "key": "val" }
                  },
                  {
                    "actionType": "custom-action2",
                    "config": { "key": "val2" }
                  }
                ],
                //list of any valid actions when lookup is unsuccessful. Mandatory
                "onFail" : [{

                }]
              },

              {
                "inputSource" : "CField",
                "ifZero" : "value2",
                "select" : [""],
                "fromDBTable" : "",
                "where" : "",
                "onPass" : [
                  {
                    "actionType": "custom-action",
                    "config": { "key": "val" }
                  },
                  {
                    "actionType": "custom-action2",
                    "config": { "key": "val2" }
                  }
                ],
                "onFail" : [{

                }]
              },

              {
                //another ifNotValid element of lookup actions and so on..
              }
            ]
          }
        },

        //-------------------------------------------------------------------//
        //split-sort-concat
        //this is a custom action that takes an input value , splits it with a comma delimiter, sorts it and returns a string seperated by with a comma on a sorted list
        {
          "actionType" : "split-sort-concat",
          "config" : {
            //mandatory field. needs an inputSource such as "xyz" to split ,sort and concat.
            //same inputSoure key is used to push enriched value to enriched.
            //e.g: "xyz" : "b,c,a" enriches to "xyz" : "a,b,c"
            "inputSource" : "xyz"
          }


        },



        //-------------------------------------------------------------------//
        //split-sort-concat-lookup
        //this is a custom action that takes an input value , splits it with a comma delimiter, sorts it and
        //forms a string seperated by with a comma on a sorted list
        // the sorted listed is now used against "in-memory" table cache lookup. This config or action should not used for JDBC. Since this action only supports tablecache lookup.
        //if JDBC is condered for the input fields,use "split-sort-concat" in the config instead.
        {
          "actionType":"split-sort-concat-lookup",
          "config":{
            "list":[
              {
                "inputSource":"special_offers_id2",
                "where":"local_offer_list",
                "select":[
                  "local_offer_group_id"
                ],
                "fromFile":"./src/test/resources/hiveTables/local_offer_group-table.json",
                "fromDBTable":"master_data.local_offer_group",
                "onFail":[
                  {
                    "actionType":"add-enriched-fields",
                    "config":[
                      {
                        "key":"local_offer_group_id",
                        "value":"0"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        },

        //------------------------------------------------------------------
        //add-device-type action
        //this is a custom action that takes input raw values of keys "channel_id", "userAgent", "deviceType",
        //processes them and outputs a hardcoded value to the field "XYZ" (see below)
        {
          "actionType" : "add-device-type",
          "config" : {
            //enrich field key name. mandatory
            "outputTarget" : "XYZ"
          }
        },


        //------------------------------------------------------------------
        //time-lookup
        //this is a custom action that takes input value from "inputSource", enriches/output to "outputTarget" field
        //by calculating the second of the day when a 24-hour time value is found in "inputSource" input value
        //if the inputValue is invalid, respective action is performed (see below)
        {
          "actionType" : "time-lookup",
          "config" : {
            //value of submitted_time to be found in input. Mandatory "inputSource"
            "inputSource":"submitted_time",

            //enrich key. Mandatory
            "outputTarget":"time_id",

            //list of actions to be mentioned when the inputvalue of submitted_time is invalid.Mandatory
            "ifInValid" : [{
              "actionType" : "reject",
              "config" : {
                "reason" : "invalid submitted_time",
                "stopProcessingActionList":false
              }
            }]
          }
        },

        //--------------------------------------------------------------------------
        //transform
        //this is a custom action where we can grab the values of the keys which are enriched so far..below is the example.
        // if input: { "a" : "A" , "b" : "B"} enriched to enriched : { "a" : "this is A" , "b" :"this is B"}
        // and if a new field needs to be added to enriched that depends on "a" and "b"
        //just use the below config which gives a new field in enriched as the following.
        //enriched : { "a" : "this is A", "b" : "this is B", "C" : "now this is A   and this is B"}
        //the transform action config MUST be put at the end of all action configs in the config file. that way we can have access to all the enriched fields.
        //this may be similar function to scratchpad.
        {
          "actionType" : "transform",
          "config" : {
            //destination is mandatory.
            "destination" : "C",
            //updateWith can be literally any text but if it has a '$' sign before a word, the compiler takes it as a key to be searched in enriched.
            //it can be combination of any text with varibles in it. example: "updateWith" : "POINT($longitude $latitude)" should give us "POINT(-67.90  86.40)",
            //if the values of latitude and longitude are in enriched. if they are not present in enriched, then an empty string is appended in place of $variable.
            //e.g: "updateWith" : "this is $xyz" should give us "this is " if 'xyz' is not enriched.
            "updateWith" : "now $a   and $b"
          }
        },

        //---------------------------------------------------------------------
        //check-web-page-type-id
        //this is a custom action that checks for value of "inputSource" from config in raw input data.
        //if "xyz" is "0" in raw input data and
        //(hardcoded in action)"web_page_type_id" value in raw input data is "2289", the actions mentioned inside "list" inner config
        //are performed.
        {
          "actionType": "check-web-page-type-id",
          "config": {
            //inputSource from input. Mandatory
            "inputSource" : "xyz",
            //list of actions to be done when "xyz" is "0" in input and "web_page_type_id" is "2289" in input. Mandatory
            "list" : [{
              "actionType" : "add-enriched-fields",
              "config" : [{
                "key" : "XXX",
                "value" : "listed"
              }]
            }]
          }
        },

        //-------------------------------------------------------------------
        //gmt-to-cst
        //custom action to change a time stamp , resgister it as GMT and convert it to CST
        {
          "actionType":"gmt-to-cst",
          "config":{
            //this inputSource value in raw input is converted to cst. Mandatory
            //any invalid value in "xyz" returns an empty enriched key/value pari
            "inputSource" : "xyz"
          }
        },


        // --------------------------------------------------------------------
        // jdbc-lookup 
        // Does a lookup using a JDBC connector.  This is much slower than a 
        // cached lookup, but can handle more complicated queries.
        {
          "actionType": "jdbc-lookup",
          "config": {

            // Jdbc client name (this is given to the framework from the 
            // application code.  See the developer of the app if you are not 
            // sure what to enter here).
            "jdbcClient": "hive",

            // "SELECT ..."
            // All of these fields (if found), will be selected and added to the 
            // enriched record (the X in "select X from ....")
            "select": [
              "some_field",
              "some_other_field"
            ],

            // -------------------------------------------------------
            // "FROM ..."
            // How to access the hive table to do the lookup.  
            // Usually this should be in the form "databaseName.tableName",
            // but may be just "tableName" if running tests with a test 
            // hive table.
            "fromDBTable": "als_search.local_offer_group",
            // -------------------------------------------------------

            // "WHERE ..."
            // The select statement "where" clause.  You can specify any 
            // valid where clause here, subject to the following limitations.
            // The field values may be in the form '$location.fieldName' where
            // location can be one of:
            //     $enriched   = read the value from a field in enriched 
            //     $input      = read the value from a field in the input record
            //     $scratchpad = read the value from a field in the scratchpad
            // 
            // The default, if not specified, is to treat the value as a constant
            // string.  Ie. "where": "fieldA = 'something'".
            // 
            // Please note that the parser will fail to read the data if this format
            // is incorrect:
            //   * if there are more than one (.) in the value
            //   * if the value is not surrounded by single quotes ('like this')
            // 
            // For example:
            "where": "fieldA = '$scratchpad.someField' and fieldB = '$input.someField2'",

            // (OPTIONAL) If the lookup succeeds, all the actions in the onPass 
            // list will be run. 
            "onPass": [
              {
                "actionType": "custom-action",
                "config": { "key": "val" }
              },
              {
                "actionType": "custom-action2",
                "config": { "key": "val2" }
              }
            ],

            // (OPTIONAL) If the lookup fails, all the actions in the onFail list 
            // will be run. 
            "onFail": [
               {
                 "actionType": "custom-action",
                 "config": { "key": "val" }
               },
               {
                 "actionType": "reject",
                 "config": {
                   "reasonFrom": "lookup"
                 }
               }
            ]
          }
        },

        // --------------------------------------------------------------------
        // Lookup 
        // Does a lookup into a pre-cached table.
        {
          "actionType": "lookup",
          "config": {

            // "SELECT ..."
            // All of these fields (if found), will be selected and added to the 
            // enriched record (the X in "select X from ....")
            "select": [
              "some_field",
              "some_other_field"
            ],

            // -------------------------------------------------------
            // "FROM ..."
            // How to access the hive table to do the lookup.  
            // Usually this should be in the form "databaseName.tableName",
            // but may be just "tableName" if running tests with a test 
            // hive table.
            "fromDBTable": "als_search.local_offer_group",

            // (Optional) If this FROM field is used, a temporary table will be 
            // registered with Hive and created from the specified file.  (This 
            // field will probably only be used during tests.)  The file must 
            // follow a specific format; see the wiki for more details: 
            // https://confluence.cars.com/display/HAD/Testing+Spark+Applications+That+Use+Hive
            "fromFile": "./path/to/a/local/file.json",
            // -------------------------------------------------------

            // "WHERE ..."
            // Field to look up (lookup on the value of the source field).  
            // This field is always required.
            "where": "ods_local_offer_id",

            // "= ..." (EQUALS)
            // This is the value to look up on.  
            // (The 'X' in "select ... where A = X").
            "equals": "front_door_affiliate_pty_id",

            // (OPTIONAL) If the lookup succeeds, all the actions in the onPass 
            // list will be run. 
            "onPass": [
              {
                "actionType": "custom-action",
                "config": { "key": "val" }
              },
              {
                "actionType": "custom-action2",
                "config": { "key": "val2" }
              }
            ],

            // (OPTIONAL) If the lookup fails, all the actions in the onFail list 
            // will be run. 
            "onFail": [
               {
                 "actionType": "custom-action",
                 "config": { "key": "val" }
               },
               {
                 "actionType": "reject",
                 "config": {
                   "reasonFrom": "lookup"
                 }
               }
            ]
          }
        },

        // --------------------------------------------------------------------
        // Reject 
        // 
        {
          "actionType": "reject",
          "config": {

            //-------------------------------------------
            // One type of 'reason' field is required, but they are mutually exclusive;
            // so don't enter more than one:

            // Hard code the reason in the json.  This won't be modified by the
            // program or the framework at all.
            "reason": "Custom hard-coded reason.",

            // This option takes the reason from the last result string saved of 
            // this actionType.  (Each action caches a result string, if it succeeds
            // or fails).
            // For example, use the below in the onFail section of a lookup action:
            // There is a special code "unhandled-exception" that can be used if you
            // want to use a reject action in the global.exceptionHandlingList; this
            // means the stack trace from an unhandled exception as the reason.
            "reasonFrom": "lookup"
            //-------------------------------------------

            // Stop processing the action list.  The default is true as shown,
            // but if false is set here, the action list will continue processing
            // after the rejection.
            // Use with care.
            "stopProcessingActionList": true
          }
        },

        // --------------------------------------------------------------------
        // Reason for Rejection 
        //
        // Provides a way to fill a field in the enriched record with all of 
        // the collected rejection reasons.  The reasons are concatenated into
        // one string, separated by "; ".  The field name in enriched is configurable.
        // This action is best done at the end of all the items, in its own 
        // action list.
        {
          "actionType":"add-rejection-reason",
          "config": {
            // The name of the field to add to the enriched record.
            // Will not be added if there are no collected rejection reasons.
            "field": "reasonForReject"
          }
        }
      ]
    }
  ]
}


