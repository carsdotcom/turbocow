// This is an example config file detailing all of the supported standard actions 
// in the library.

{
  "activityType": "impressions",
  "items": [
    {
      // The name field is strictly for the author's use, to name this item, 
      // which is just a sequence of actions.  The best practice is to name it 
      // after the output field in the enriched record that this list generates.  
      // If it generates more than one field, name them all, or use something generic 
      // like "all the simple-copy fields".   This field is not used in the code at 
      // all.
      "name": "name_of_this_item",

      // All the actions to perform, in sequence, in order to output a specific field 
      // in the enriched record.
      "actions": [

        // --------------------------------------------------------------------
        // Custom actions can have anything in the "config" section.
        // They must have a custom ActionCreator object passed to the ActionFactory.
        // If you notice you are re-using custom actions, they may be a candidate
        // to be added to the framework.
        {
          "actionType": "custom",
          "config": {
              "any": "thing",
              "someOther": [ "things" ]
          }
        },

        // --------------------------------------------------------------------
        // Simple copy copies each source field from the input record directly to 
        // the same-named field in the output record.
        {
          "actionType": "simple-copy",
          "config": {
            "inputSource": [ "field1", "field2" ] // etc.
          }
        },

        // --------------------------------------------------------------------
        // Check does a check on a field and if it passes, runs some actions.
        // If the check fails, it runs some other actions.
        {
          "actionType": "check",

          "config": {

            // The "left" operand in the check operation.  For unary checks
            // (null, empty, etc.), this is the only operand required.
            // For unary checks, you may also name it "field", which makes more 
            // sense in this context.
            "left": "fieldA",

            // (Optional) Specify where to pull the left field from, either
            // the inputRecord or the enriched record up to this point.
            // If not specified, the default is to check the enriched record; 
            // if not found there, it looks in the inputRecord.
            // For unary checks, you may also name it "fieldSource", which makes 
            // more sense in this context.
            "leftSource": "enriched|input"

            // The operator.  Valid operators are currently:
            //   * empty
            //   * non-empty
            //   * null
            //   * non-null
            //   * numeric
            //   * non-numeric
            "op": "non-empty",

            // Note - binary checks are unimplemented yet, but this is how they
            // would be configured (using "right" and "rightSource", below):
            
            // (OPTIONAL) The right-hand operand.  This is required for binary 
            // checks (such as "<" or "=").  If this is NOT a binary check (only
            // one field is being analyzed), and this is specified, the parser
            // will error out and let you know.
            //"right": "fieldB",

            // (OPTIONAL) Specify where to pull the right field from, either
            // the inputRecord or the enriched record up to this point.
            // If not specified, the default is to check the enriched record; 
            // if not found there, it looks in the inputRecord.
            //"rightSource": "enriched|input",

            // (OPTIONAL) If the check passes (the result is 'yes' or 'true'), then 
            // all of the actions in the onPass list will be run. 
            "onPass": [
              {
                "actionType": "custom-action",
                "config": { "key": "val" }
              },
              {
                "actionType": "custom-action2",
                "config": { "key": "val2" }
              }
            ],

            // (OPTIONAL) If the check fails (the result is 'no' or 'false'), then 
            // all of the actions in the onPass list will be run. 
            "onFail": [
               {
                 "actionType": "custom-action",
                 "config": { "key": "val" }
               },
               {
                 "actionType": "reject",
                 "config": {
                   "reasonFrom": "check"
                 }
               }
            ]
          }
        }

        // --------------------------------------------------------------------
        // Copy copies a field's value into a potentially-differently-named field.
        // More configurable than simple-copy.  For each element in config, 
        // you must specify a 'source' and an 'enrichedField' (destination).
        {
          "actionType": "copy",
          "config": {
            "config": [
              {
                "inputSource":  "name_of_field_from_input_record", 
                "outputTarget": "name_of_field_in_output_record"
              },
              {
                "inputSource":  "name_of_field_from_input_record2", 
                "outputTarget": "name_of_field_in_output_record2"
              }
              // etc.
            ]
          }
        },

        // --------------------------------------------------------------------
        // "Replace Null" checks for a null value in the input field(s),
        // and if the value exists and is null (or does not exist), it will set 
        // the enriched record's field value to be some hard-coded value.  
        {
          "actionType": "replace-null",
          "config": {

            // Either 'field' or 'fields' must be specified, or there is an error.
            // This is the field (or fields) to check for null, and if they are
            // null or missing in the input, then the new value is written.
            // By default, the field is searched for first in the enriched record, 
            // then if not found, the input record is searched.  This can be 
            // overridden by specifying a location modifier in front of the field 
            // like so:
            //
            //    "$enriched.fieldA" = search the enriched record only
            //    "$input.fieldA" = search the input record only
            "field":  "fieldA",
            "fields": [ "fieldB", "fieldC", "..."],

            // This is the exact value to write for this field.  
            "newValue": "Some text",

            // Specify where the new value is written to.  Valid values are:
            //   "enriched" = the enriched record (the default; not necessary to specify)
            //   "scratchpad" = the scratchpad (temporary storage, only lives for 
            //                  while this record is being processed - from this
            //                  point forward)
            "outputTo": "scratchpad",
          }
        },

        // --------------------------------------------------------------------
        // Lookup 
        // Does a lookup into a pre-cached table.
        // Requires "source" field[s].
        {
          "actionType": "lookup",
          "config": {

            // "SELECT ..."
            // All of these fields (if found), will be selected and added to the 
            // enriched record (the X in "select X from ....")
            "select": [
              "some_field",
              "some_other_field"
            ],

            // -------------------------------------------------------
            // "FROM ..."
            // How to access the hive table to do the lookup.  
            // Usually this should be in the form "databaseName.tableName",
            // but may be just "tableName" if running tests with a test 
            // hive table.
            "fromDBTable": "als_search.local_offer_group",

            // (Optional) If this FROM field is used, a temporary table will be 
            // registered with Hive and created from the specified file.  (This 
            // field will probably only be used during tests.)  The file must 
            // follow a specific format; see the wiki for more details: 
            // https://confluence.cars.com/display/HAD/Testing+Spark+Applications+That+Use+Hive
            "fromFile": "./path/to/a/local/file.json",
            // -------------------------------------------------------

            // "WHERE ..."
            // Field to look up (lookup on the value of the source field).  
            // This field is always required.
            "where": "ods_local_offer_id",

            // "= ..." (EQUALS)
            // This is the value to look up on.  
            // (The 'X' in "select ... where A = X").
            "equals": "front_door_affiliate_pty_id",

            // (OPTIONAL) If the lookup succeeds, all the actions in the onPass 
            // list will be run. 
            "onPass": [
              {
                "actionType": "custom-action",
                "config": { "key": "val" }
              },
              {
                "actionType": "custom-action2",
                "config": { "key": "val2" }
              }
            ],

            // (OPTIONAL) If the lookup fails, all the actions in the onFail list 
            // will be run. 
            "onFail": [
               {
                 "actionType": "custom-action",
                 "config": { "key": "val" }
               },
               {
                 "actionType": "reject",
                 "config": {
                   "reasonFrom": "lookup"
                 }
               }
            ]
          }
        },

        // --------------------------------------------------------------------
        // Reject 
        // 
        {
          "actionType": "reject",
          "config": {

            //-------------------------------------------
            // One type of 'reason' field is required, but they are mutually exclusive;
            // so don't enter more than one:

            // Hard code the reason in the json.  This won't be modified by the
            // program or the framework at all.
            "reason": "Custom hard-coded reason.",

            // This option takes the reason from the last result string saved of 
            // this actionType.  (Each action caches a result string, if it succeeds
            // or fails).
            // For example, use the below in the onFail section of a lookup action:
            "reasonFrom": "lookup"
            //-------------------------------------------

            // Stop processing the action list.  The default is true as shown,
            // but if false is set here, the action list will continue processing
            // after the rejection.
            // Use with care.
            "stopProcessingActionList": true
          }
        },

        // --------------------------------------------------------------------
        // Reason for Rejection 
        //
        // Provides a way to fill a field in the enriched record with all of 
        // the collected rejection reasons.  The reasons are concatenated into
        // one string, separated by "; ".  The field name in enriched is configurable.
        // This action is best done at the end of all the items, in its own 
        // action list.
        {
          "actionType":"add-rejection-reason",
          "config": {
            // The name of the field to add to the enriched record.
            // Will not be added if there are no collected rejection reasons.
            "field": "reasonForReject"
          }
        }
      ]
    }
  ]
}


